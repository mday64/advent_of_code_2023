General
-------
Add time and memory profiling.

Day 1
-----
* Convert to a proper parser, like nom.

Day 2
-----
* Convert to a proper parser, like nom.

Day 3
-----
* Make it more elegant, less brute force imperative style.
* Combine parts 1 and 2 so they can be computed at the same time.
* Is there a better way to find symbols adjacent to numbers?

Day 4
-----
* It feels like there should be a more elegant way to count_matches without
  building a Vec of all the numbers first.  We ought to be able to build the
  HashSet directly, while counting the number of times we iterate (though we
  do need to avoid counting the vertical bar, or subtract 1 to account for it).

  Maybe use fold() to maintain a counter while iterating over numbers (fed into
  a HashSet collect).  Or use a mutable variable that gets incremented.

Day 10
------
* For part 2, try "ray casting."  As you move in a straight line, an even
  number of crossings means outside, and odd number of crossings is inside.
  Be careful about the very edge (going along the pipe or its edge).
  I think it would be easiest to cast horizontal rays (so you can do a whole
  line at once).  For consistency, pretend you're casting a ray just below
  the midline of the row.  So a crossing is "|", "F", or "7".  Don't forget
  to figure out which shape the pipe at "S" is, and use that shape for counting
  crossings.  When you hit a space that isn't part of the loop, count it as
  "inside" if there have been an odd number of crossings.
Day 11
------
* Part 1 is slow in debug mode.  Where is the time being spent?  My guess is
  in iterating over rows and cols and lookup in occupied_rows and occupied_cols,
  to determine how much to modify the Manhattan distances.  I wonder if it would
  be faster to adjust all of the row and column numbers up front?
